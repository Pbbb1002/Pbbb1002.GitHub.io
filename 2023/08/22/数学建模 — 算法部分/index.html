<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="​                                         规划篇线性规划线性规则求解需清晰两部分，目标函数（max， min）和约束条件（s.t.），求解前应转化为标准形式：  数 (c)：目标函数是一个线性表达式，由变量的系数组成。目标是最小化目标函数的值。c 是一个包含每个变量对应系数的向量。       不等式约束系数矩阵 A和不等式约束右侧向量 b：不等式约束表示">
<meta property="og:type" content="article">
<meta property="og:title" content="数学建模——算法部分">
<meta property="og:url" content="http://example.com/2023/08/22/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%20%E2%80%94%20%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/index.html">
<meta property="og:site_name" content="Pbbb&#39;s Blog">
<meta property="og:description" content="​                                         规划篇线性规划线性规则求解需清晰两部分，目标函数（max， min）和约束条件（s.t.），求解前应转化为标准形式：  数 (c)：目标函数是一个线性表达式，由变量的系数组成。目标是最小化目标函数的值。c 是一个包含每个变量对应系数的向量。       不等式约束系数矩阵 A和不等式约束右侧向量 b：不等式约束表示">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822174736880.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822010055783.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822011243453.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822012615376.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230823010444486.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230823005425878.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230825235208763.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826000031872.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826000814543.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826000910601.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826201423734.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826201627590.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826202852564.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826203853696.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826204232673.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826204350030.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230828012347590.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230828012502430.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903213419486.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903213707600.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903213852282.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903214155404.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903214510393.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903214905998.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903215623369.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903220455022.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903221254735.png">
<meta property="article:published_time" content="2023-08-21T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-05T13:16:34.242Z">
<meta property="article:author" content="彭 斌">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="建模">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822174736880.png">


<link rel="canonical" href="http://example.com/2023/08/22/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%20%E2%80%94%20%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/08/22/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%20%E2%80%94%20%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/","path":"2023/08/22/数学建模 — 算法部分/","title":"数学建模——算法部分"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数学建模——算法部分 | Pbbb's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Pbbb's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%84%E5%88%92%E7%AF%87"><span class="nav-number">1.</span> <span class="nav-text">规划篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92"><span class="nav-number">1.1.</span> <span class="nav-text">线性规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MATLAB%E6%B1%82%E8%A7%A3%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.1.1.</span> <span class="nav-text">MATLAB求解代码：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E7%9A%84scipy%E5%BA%93%E6%B1%82%E8%A7%A3%EF%BC%9A"><span class="nav-number">1.1.2.</span> <span class="nav-text">Python的scipy库求解：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E7%9A%84pulp%E5%BA%93%E6%B1%82%E8%A7%A3%EF%BC%9A"><span class="nav-number">1.1.3.</span> <span class="nav-text">Python的pulp库求解：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.4.</span> <span class="nav-text">运输问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.5.</span> <span class="nav-text">指派问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92"><span class="nav-number">1.2.</span> <span class="nav-text">整数规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.1.</span> <span class="nav-text">分支定界问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">匈牙利法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92"><span class="nav-number">1.3.</span> <span class="nav-text">非线性规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">蒙特卡洛法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">1.4.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.1.</span> <span class="nav-text">*贪心策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">图论模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">图的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="nav-number">2.1.1.</span> <span class="nav-text">常用术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E6%9D%83%E5%9B%BE%E5%92%8C%E5%AD%90%E5%9B%BE"><span class="nav-number">2.1.2.</span> <span class="nav-text">赋权图和子图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">基本概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.1.3.</span> <span class="nav-text">图的矩阵表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%A1%B6%E7%82%B9%E5%BA%A6"><span class="nav-number">2.1.4.</span> <span class="nav-text">图的顶点度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%92%8C%E8%BF%9E%E9%80%9A"><span class="nav-number">2.1.5.</span> <span class="nav-text">路和连通</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">最短路问题及算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">Dijkstra算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#matlab%E5%AE%9E%E7%8E%B0Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">matlab实现Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python%E5%AE%9E%E7%8E%B0Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">Python实现Dijkstra算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%A7%84%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">多目标规化模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">3.1.</span> <span class="nav-text">解的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3A%E4%BC%98%E4%BA%8E%E8%A7%A3B"><span class="nav-number">3.1.1.</span> <span class="nav-text">解A优于解B</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3A%E6%97%A0%E5%B7%AE%E5%88%AB%E4%BA%8E%E8%A7%A3B"><span class="nav-number">3.1.2.</span> <span class="nav-text">解A无差别于解B</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E8%A7%A3"><span class="nav-number">3.1.3.</span> <span class="nav-text">最优解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%95%E7%B4%AF%E6%89%98%E6%9C%80%E4%BC%98"><span class="nav-number">3.2.</span> <span class="nav-text">帕累托最优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%95%E7%B4%AF%E6%89%98%E6%9C%80%E4%BC%98%E8%A7%A3"><span class="nav-number">3.2.1.</span> <span class="nav-text">帕累托最优解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%95%E7%B4%AF%E6%89%98%E6%9C%80%E4%BC%98%E5%89%8D%E6%B2%BF"><span class="nav-number">3.2.2.</span> <span class="nav-text">帕累托最优前沿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E8%A7%A3%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">传统解法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8A%A0%E6%9D%83%E6%B3%95"><span class="nav-number">3.3.1.</span> <span class="nav-text">线性加权法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E6%B3%95"><span class="nav-number">3.3.2.</span> <span class="nav-text">优先级法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E6%83%B3%E7%82%B9%E6%B3%95"><span class="nav-number">3.3.3.</span> <span class="nav-text">理想点法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">智能算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.1.</span> <span class="nav-text">遗传算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">分类算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92"><span class="nav-number">4.1.</span> <span class="nav-text">逻辑回归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">聚类算法</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="彭 斌"
      src="/images/sunflower.jpg">
  <p class="site-author-name" itemprop="name">彭 斌</p>
  <div class="site-description" itemprop="description">难怪我永远怀念飞灰</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%20%E2%80%94%20%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sunflower.jpg">
      <meta itemprop="name" content="彭 斌">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pbbb's Blog">
      <meta itemprop="description" content="难怪我永远怀念飞灰">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数学建模——算法部分 | Pbbb's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数学建模——算法部分
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-22 00:00:00" itemprop="dateCreated datePublished" datetime="2023-08-22T00:00:00+08:00">2023-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 21:16:34" itemprop="dateModified" datetime="2023-09-05T21:16:34+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/MATLAB/" itemprop="url" rel="index"><span itemprop="name">MATLAB</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/MATLAB/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" itemprop="url" rel="index"><span itemprop="name">数学建模</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>​                                        <!-- 展开全文 --></p>
<h1 id="规划篇"><a href="#规划篇" class="headerlink" title="规划篇"></a>规划篇</h1><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>线性规则求解需清晰两部分，目标函数（max， min）和约束条件（s.t.），求解前应转化为标准形式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822174736880.png" alt="image-20230822174736880"></p>
<p>数 (c)：目标函数是一个线性表达式，由变量的系数组成。目标是最小化目标函数的值。c 是一个包含每个变量对应系数的向量。<br>       不等式约束系数矩阵 A和不等式约束右侧向量 b：不等式约束表示为 A* x ≤ b，其中 A是一个矩阵，每行表示一个约束条件的系数，b 是一个向量，表示对应约束条件的右侧值。<br>       等式约束系数矩阵 Aeq 和等式约束右侧向量 beq：等式约束表示为 Aeq * x &#x3D; beq，其中 Aeq 是一个矩阵，每行表示一个约束条件的系数，beq 是一个向量，表示对应约束条件的右侧值。<br>       变量的下界lb和ub：变量的下界是一个向量，表示每个变量的最小取值限制。默认情况下，变量没有下界限制，可以通过设置 bounds 参数来指定。</p>
<h3 id="MATLAB求解代码："><a href="#MATLAB求解代码：" class="headerlink" title="MATLAB求解代码："></a>MATLAB求解代码：</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x, fval] = linprog(c, A, b, Aeq, beq, LB, UB, X0, OPTIONS)</span><br><span class="line"># LB和UB分别为x的上界和下界</span><br></pre></td></tr></table></figure>

<h3 id="Python的scipy库求解："><a href="#Python的scipy库求解：" class="headerlink" title="Python的scipy库求解："></a>Python的scipy库求解：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 求解函数</span></span><br><span class="line">res = optimize.linprog(c, A, b, Aeq, beq, LB, UB, X0, OPTIONS)</span><br><span class="line"><span class="comment"># 若求最大值，在c前加上负号</span></span><br><span class="line"><span class="comment"># 目标函数最小值</span></span><br><span class="line"><span class="built_in">print</span>(res.fun)</span><br><span class="line"><span class="comment"># 最优解</span></span><br><span class="line"><span class="built_in">print</span>(res.x)</span><br></pre></td></tr></table></figure>

<p>演示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822010055783.png" alt="image-20230822010055783"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 确定c,A,b,Aeq,ceq</span></span><br><span class="line">c = np.array([<span class="number">2</span>, <span class="number">3</span>, -<span class="number">5</span>])</span><br><span class="line">A = np.array([[-<span class="number">2</span>, <span class="number">5</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]]) <span class="comment"># 约束条件为大于号，系数前要加负号</span></span><br><span class="line">B = np.array([-<span class="number">10</span>, <span class="number">12</span>])</span><br><span class="line">Aeq = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">Beq = np.array([<span class="number">7</span>])</span><br><span class="line"><span class="comment"># 求解</span></span><br><span class="line">res = optimize.linprog(-c, A, b, Aeq, Beq) <span class="comment"># 求最大值，c前要加负号</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h3 id="Python的pulp库求解："><a href="#Python的pulp库求解：" class="headerlink" title="Python的pulp库求解："></a>Python的pulp库求解：</h3><p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822011243453.png" alt="image-20230822011243453"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pulp</span><br><span class="line"><span class="comment"># 目标函数的系数</span></span><br><span class="line">z = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 约束</span></span><br><span class="line">a = [[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>]]</span><br><span class="line">b = [<span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 确定最大最小化问题，最大化只要把min改为max即可</span></span><br><span class="line">m = pulp.LpProblem(sense=pulp.LpMinimize)</span><br><span class="line"><span class="comment"># 定义三个变量放在列表中</span></span><br><span class="line">x = [pulp.LpVariable(<span class="string">f&#x27;x<span class="subst">&#123;i&#125;</span>&#x27;</span>, lowBound=<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="comment"># 定义目标函数，LpDot可以将两个列表的对应位相乘再加和</span></span><br><span class="line"><span class="comment"># 相当于z[0]*x[0]+z[1]*x[1]+z[2]*x[2]</span></span><br><span class="line">m += pulp.lpDot(z, x)</span><br><span class="line"><span class="comment"># 添加约束</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    m += pulp.lpDot(a[i], x) &gt;= b[i]</span><br><span class="line"><span class="comment"># 求解</span></span><br><span class="line">m.solve()</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> m.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优值:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(pulp.value(m.objective))d = <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 定义目标函数，LpDot可以将两个列表的对应位相乘再加和</span></span><br><span class="line"><span class="comment"># 相当于z[0]*x[0]+z[1]*x[1]+Z[2]*x[2]</span></span><br><span class="line"><span class="comment"># m += pulp.lpDot(z, x)</span></span><br></pre></td></tr></table></figure>

<h3 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a>运输问题</h3><p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230822012615376.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pulp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transportation_problem</span>(<span class="params">costs, x_max, y_max</span>):</span><br><span class="line">    <span class="comment"># 获取运输问题的行数和列数</span></span><br><span class="line">    row = <span class="built_in">len</span>(costs)</span><br><span class="line">    col = <span class="built_in">len</span>(costs[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 创建线性规划问题对象</span></span><br><span class="line">    prob = pulp.LpProblem(<span class="string">&#x27;Transportation Problem&#x27;</span>, sense=pulp.LpMaximize)</span><br><span class="line">    <span class="comment"># 创建变量</span></span><br><span class="line">    var = [[pulp.LpVariable(<span class="string">f&#x27;x<span class="subst">&#123;i&#125;</span><span class="subst">&#123;j&#125;</span>&#x27;</span>, lowBound=<span class="number">0</span>, cat=pulp.LpInteger) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line">    <span class="comment"># 定义flatten函数，用于将嵌套的列表展开成一维列表</span></span><br><span class="line">    flatten = <span class="keyword">lambda</span> x: [y <span class="keyword">for</span> l <span class="keyword">in</span> x <span class="keyword">for</span> y <span class="keyword">in</span> flatten(l)] <span class="keyword">if</span> <span class="built_in">type</span>(x) <span class="keyword">is</span> <span class="built_in">list</span> <span class="keyword">else</span> [x]</span><br><span class="line">    <span class="comment"># 定义目标函数</span></span><br><span class="line">    prob += pulp.lpDot(flatten(var), costs.flatten())</span><br><span class="line">    <span class="comment"># 添加供应约束</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">        prob += pulp.lpSum(var[i]) &lt;= x_max[i]</span><br><span class="line">    <span class="comment"># 添加需求约束</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">        prob += pulp.lpSum(var[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row)) &lt;= y_max[j]</span><br><span class="line">    <span class="comment"># 求解线性规划问题</span></span><br><span class="line">    prob.solve()</span><br><span class="line">    <span class="comment"># 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;objective&#x27;</span>: pulp.value(prob.objective), <span class="string">&#x27;var&#x27;</span>: [[pulp.value(var[i][j]) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row)]&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">costs = np.array([[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">                  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                  [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">x_max = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">y_max = [<span class="number">15</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">result = transportation_problem(costs, x_max, y_max)</span><br><span class="line">pprint(result)</span><br></pre></td></tr></table></figure>

<p>在示例中，将运输成本矩阵costs、供应限制向量x_max和需求限制向量y_max作为参数传递给transportation_problem函数，并打印结果。</p>
<h3 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h3><h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><p>整数规划的模型和线性规划基本相同，只是额外添加了部分变量为整数的约束<br>       整数规划求解的基本框架时分支定界法，首先去除整数约束得到‘松弛模型’，使用线性规划的方法求解。<br>       若有某个变量不是整数，在松弛模型上分别添加约束：x &lt;&#x3D; floor(A)和x &gt;&#x3D; ceil(A)，然后再分别求解，这个过程叫<strong>分支</strong>。当节点求解结果中所有变量都是整数时，停止分支。这样不断迭代形成了一颗树。<br>       所谓定界，指的是叶子节点产生后，相当于给问题指定了一个下界。之后在求解过程中一旦在某个节点的目标函数值小于这个下界就直接跳过不再进行分支；每次新产生叶子节点，则更新下界       </p>
<h3 id="分支定界问题"><a href="#分支定界问题" class="headerlink" title="分支定界问题"></a>分支定界问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branch_and_bound</span>(<span class="params">c, A, b, x_low, x_high</span>):</span><br><span class="line">    best_obj = np.inf  <span class="comment"># 初始化最优解的目标函数值为正无穷大</span></span><br><span class="line">    best_x = <span class="literal">None</span>  <span class="comment"># 初始化最优解的变量取值为空</span></span><br><span class="line">    <span class="comment"># 创建优先队列</span></span><br><span class="line">    pq = PriorityQueue()</span><br><span class="line">    <span class="comment"># 将原始问题的目标函数值、变量下界和变量上界作为一个节点加入优先队列</span></span><br><span class="line">    pq.put((<span class="number">0</span>, x_low, x_high))</span><br><span class="line">    <span class="comment"># 主循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> pq.empty():</span><br><span class="line">        <span class="comment"># 取出队列中的节点</span></span><br><span class="line">        node = pq.get()</span><br><span class="line">        node_obj, node_x_low, node_x_high = node</span><br><span class="line">        <span class="comment"># 检查节点的目标函数值是否超过了当前找到的最优解的目标函数值</span></span><br><span class="line">        <span class="keyword">if</span> node_obj &gt; best_obj:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 检查终止条件：检查节点的变量下界和变量上界是否相等</span></span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">all</span>(node_x_low == node_x_high):</span><br><span class="line">            <span class="comment"># 更新最优解的目标函数值和变量取值</span></span><br><span class="line">            <span class="keyword">if</span> node_obj &lt; best_obj:</span><br><span class="line">                best_obj = node_obj</span><br><span class="line">                best_x = node_x_low</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 进行分支</span></span><br><span class="line">        <span class="comment"># 选择一个未分支的变量</span></span><br><span class="line">        branch_var = np.argmax(node_x_high - node_x_low)</span><br><span class="line">        <span class="comment"># 根据分支变量的下界和上界创建两个新的节点</span></span><br><span class="line">        branch_val = <span class="built_in">int</span>(np.ceil((node_x_low[branch_var] + node_x_high[branch_var]) / <span class="number">2</span>))        </span><br><span class="line">        <span class="comment"># 创建左子节点</span></span><br><span class="line">        left_x_low = np.copy(node_x_low)</span><br><span class="line">        left_x_high = np.copy(node_x_high)</span><br><span class="line">        left_x_high[branch_var] = branch_val</span><br><span class="line">        pq.put((node_obj + c[branch_var] * branch_val, left_x_low, left_x_high))</span><br><span class="line">        <span class="comment"># 创建右子节点</span></span><br><span class="line">        right_x_low = np.copy(node_x_low)</span><br><span class="line">        right_x_low[branch_var] = branch_val + <span class="number">1</span></span><br><span class="line">        pq.put((node_obj, right_x_low, node_x_high))</span><br><span class="line">    <span class="keyword">return</span> best_obj, best_x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备输入数据</span></span><br><span class="line">c = np.array([<span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 目标函数的系数向量</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>]])  <span class="comment"># 约束条件的系数矩阵</span></span><br><span class="line">b = np.array([<span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># 约束条件的右侧向量</span></span><br><span class="line">x_low = np.array([<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 变量的下界向量</span></span><br><span class="line">x_high = np.array([np.inf, np.inf])  <span class="comment"># 变量的上界向量</span></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">best_obj, best_x = branch_and_bound(c, A, b, x_low, x_high)</span><br><span class="line"><span class="comment"># 处理结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解的目标函数值:&quot;</span>, best_obj)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解的变量取值:&quot;</span>, best_x)</span><br></pre></td></tr></table></figure>

<h3 id="匈牙利法"><a href="#匈牙利法" class="headerlink" title="匈牙利法"></a>匈牙利法</h3><p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230823010444486.png" alt="image-20230823010444486"></p>
<p>匈牙利算法适用于解决以下类型的问题：</p>
<ol>
<li>二分图最大权匹配问题：给定一个二分图，每条边都有一个权重，目标是找到一个匹配，使得匹配的边的权重之和最大化。匈牙利算法可以用于解决这个问题。</li>
<li>任务分配问题：假设有一组任务和一组可执行任务的人员，每个人员对于执行每个任务都有一个成本或权重。任务分配问题的目标是将任务分配给人员，使得总成本或总权重最小化。匈牙利算法可以用于解决这个问题。</li>
<li>最大独立集问题：给定一个无向图，目标是找到一个具有最大顶点数的独立集，其中任意两个顶点之间不存在边。匈牙利算法可以用于解决这个问题。</li>
<li>最小顶点覆盖问题：给定一个无向图，目标是找到一个顶点集，使得每条边都至少与该集中的一个顶点相邻，且所选顶点的数量最小。匈牙利算法可以用于解决这个问题。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hungarian_algorithm</span>(<span class="params">cost_matrix</span>):</span><br><span class="line">    num_rows = <span class="built_in">len</span>(cost_matrix)</span><br><span class="line">    num_cols = <span class="built_in">len</span>(cost_matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化标记数组和匹配数组</span></span><br><span class="line">    row_covered = [<span class="literal">False</span>] * num_rows</span><br><span class="line">    col_covered = [<span class="literal">False</span>] * num_cols</span><br><span class="line">    matching = [-<span class="number">1</span>] * num_rows</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤1：行减最小值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_rows):</span><br><span class="line">        min_val = <span class="built_in">min</span>(cost_matrix[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_cols):</span><br><span class="line">            cost_matrix[i][j] -= min_val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行匹配</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_rows):</span><br><span class="line">        <span class="comment"># 步骤2：寻找零元素</span></span><br><span class="line">        zeros = find_zeros(cost_matrix, row_covered, col_covered)</span><br><span class="line">        <span class="keyword">while</span> zeros:</span><br><span class="line">            row, col = zeros.pop()</span><br><span class="line">            <span class="keyword">if</span> matching[row] == -<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 步骤3：找到未匹配的零元素</span></span><br><span class="line">                matching[row] = col</span><br><span class="line">                row_covered[row] = <span class="literal">True</span></span><br><span class="line">                col_covered[col] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 步骤4：更新标记数组并寻找增广路径</span></span><br><span class="line">                prev_col = matching[row]</span><br><span class="line">                col_covered[prev_col] = <span class="literal">False</span></span><br><span class="line">                row_covered[row] = <span class="literal">True</span></span><br><span class="line">                zeros = find_zeros(cost_matrix, row_covered, col_covered)</span><br><span class="line">                zeros.append((row, col))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matching</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_zeros</span>(<span class="params">cost_matrix, row_covered, col_covered</span>):</span><br><span class="line">    zeros = []</span><br><span class="line">    <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(cost_matrix):</span><br><span class="line">        <span class="keyword">for</span> j, cost <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">            <span class="keyword">if</span> cost == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> row_covered[i] <span class="keyword">and</span> <span class="keyword">not</span> col_covered[j]:</span><br><span class="line">                zeros.append((i, j))</span><br><span class="line">    <span class="keyword">return</span> zeros</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例成本矩阵</span></span><br><span class="line">cost_matrix = [</span><br><span class="line">    [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">matching = hungarian_algorithm(cost_matrix)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳匹配结果：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(matching):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;行 <span class="subst">&#123;row&#125;</span> &lt;-&gt; 列 <span class="subst">&#123;col&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>matlab实现匈牙利法：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matching</span> = <span class="title">hungarian_algorithm</span><span class="params">(cost_matrix)</span></span></span><br><span class="line">    num_rows = <span class="built_in">size</span>(cost_matrix, <span class="number">1</span>);</span><br><span class="line">    num_cols = <span class="built_in">size</span>(cost_matrix, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 初始化标记数组和匹配数组</span></span><br><span class="line">    row_covered = <span class="built_in">false</span>(<span class="number">1</span>, num_rows);</span><br><span class="line">    col_covered = <span class="built_in">false</span>(<span class="number">1</span>, num_cols);</span><br><span class="line">    matching = -<span class="built_in">ones</span>(<span class="number">1</span>, num_rows);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 步骤1：行减最小值</span></span><br><span class="line">    min_vals = <span class="built_in">min</span>(cost_matrix, [], <span class="number">2</span>);</span><br><span class="line">    cost_matrix = cost_matrix - min_vals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 进行匹配</span></span><br><span class="line">    <span class="keyword">for</span> ~ = <span class="number">1</span>:num_rows</span><br><span class="line">        <span class="comment">% 步骤2：寻找零元素</span></span><br><span class="line">        <span class="built_in">zeros</span> = find_zeros(cost_matrix, row_covered, col_covered);</span><br><span class="line">        <span class="keyword">while</span> ~<span class="built_in">isempty</span>(<span class="built_in">zeros</span>)</span><br><span class="line">            [row, col] = <span class="built_in">zeros</span>(<span class="number">1</span>, :);</span><br><span class="line">            <span class="keyword">if</span> matching(row) == <span class="number">-1</span></span><br><span class="line">                <span class="comment">% 步骤3：找到未匹配的零元素</span></span><br><span class="line">                matching(row) = col;</span><br><span class="line">                row_covered(row) = <span class="built_in">true</span>;</span><br><span class="line">                col_covered(col) = <span class="built_in">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">% 步骤4：更新标记数组并寻找增广路径</span></span><br><span class="line">                prev_col = matching(row);</span><br><span class="line">                col_covered(prev_col) = <span class="built_in">false</span>;</span><br><span class="line">                row_covered(row) = <span class="built_in">true</span>;</span><br><span class="line">                <span class="built_in">zeros</span> = find_zeros(cost_matrix, row_covered, col_covered);</span><br><span class="line">                <span class="built_in">zeros</span> = [<span class="built_in">zeros</span>; row, col];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zeros</span> = <span class="title">find_zeros</span><span class="params">(cost_matrix, row_covered, col_covered)</span></span></span><br><span class="line">    <span class="built_in">zeros</span> = [];</span><br><span class="line">    [rows, cols] = <span class="built_in">size</span>(cost_matrix);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:rows</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:cols</span><br><span class="line">            <span class="keyword">if</span> cost_matrix(<span class="built_in">i</span>, <span class="built_in">j</span>) == <span class="number">0</span> &amp;&amp; ~row_covered(<span class="built_in">i</span>) &amp;&amp; ~col_covered(<span class="built_in">j</span>)</span><br><span class="line">                <span class="built_in">zeros</span> = [<span class="built_in">zeros</span>; <span class="built_in">i</span>, <span class="built_in">j</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 示例成本矩阵</span></span><br><span class="line">cost_matrix = [</span><br><span class="line">    <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>;</span><br><span class="line">    <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>;</span><br><span class="line">    <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">matching = hungarian_algorithm(cost_matrix);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最佳匹配结果:&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> row = <span class="number">1</span>:<span class="built_in">length</span>(matching)</span><br><span class="line">    col = matching(row);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;行 &#x27;</span>, num2str(row), <span class="string">&#x27; &lt;-&gt; 列 &#x27;</span>, num2str(col)]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h2><p>非线性规划可以简单分为两种，目标函数为凸函数或为非凸函数。</p>
<p>凸函数的非线性规划有很多常用的库，比如cvxpy：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="comment"># objective是目标函数，constraints是约束条件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_nonlinear_program</span>(<span class="params">objective, constraints</span>):</span><br><span class="line">    <span class="comment"># 定义变量</span></span><br><span class="line">    x = cp.Variable(n)</span><br><span class="line">    <span class="comment"># 创建问题</span></span><br><span class="line">    problem = cp.Problem(cp.Minimize(objective), constraints)</span><br><span class="line">    <span class="comment"># 求解问题</span></span><br><span class="line">    problem.solve() </span><br><span class="line">    <span class="comment"># 分析结果</span></span><br><span class="line">    optimal_solution = x.value</span><br><span class="line">    optimal_value = problem.value</span><br><span class="line">    <span class="keyword">return</span> optimal_solution, optimal_value</span><br></pre></td></tr></table></figure>

<p>非凸函数的非线性规划（求极值），可以尝试纯数学方法（求导求极值）、神经网络、深度学习等</p>
<h3 id="蒙特卡洛法"><a href="#蒙特卡洛法" class="headerlink" title="蒙特卡洛法"></a>蒙特卡洛法</h3><p>基本思想：当可行域过大，无法求得精确解时，进行<strong>随机抽样</strong>，根据<strong>统计试验</strong>求近似值</p>
<p>代码求解：以近似计算圆周率为例</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">200000</span>;</span><br><span class="line">n = <span class="number">0</span>; <span class="comment">% 初始化落在单位圆内的点的数量</span></span><br><span class="line"><span class="built_in">figure</span>; <span class="comment">% 创建一个新的绘图窗口</span></span><br><span class="line"><span class="built_in">hold</span> on; <span class="comment">% 保持绘图窗口多次绘图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:p <span class="comment">% 对于要投放的总共p个点</span></span><br><span class="line">    <span class="comment">% rand函数产生在(0, 1)之间的随机数</span></span><br><span class="line">    px = <span class="built_in">rand</span>*<span class="number">2</span>; <span class="comment">% 随机生成该点的横坐标</span></span><br><span class="line">    py = <span class="built_in">rand</span>*<span class="number">2</span>; <span class="comment">% 随机生成该点的纵坐标</span></span><br><span class="line">    <span class="keyword">if</span> (px<span class="number">-1</span>)^<span class="number">2</span> + (py<span class="number">-1</span>)^<span class="number">2</span> &lt; <span class="number">1</span></span><br><span class="line">        <span class="built_in">plot</span>(px, py, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        n = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">plot</span>(px, py, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">axis equal; <span class="comment">% 绘图时横纵坐标单位长度相同，便于观察圆</span></span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>); <span class="comment">% 添加x轴标签</span></span><br><span class="line">ylabel(<span class="string">&#x27;y&#x27;</span>); <span class="comment">% 添加y轴标签</span></span><br><span class="line">title(<span class="string">&#x27;Monte Carlo Simulation&#x27;</span>); <span class="comment">% 添加标题</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Inside Circle&#x27;</span>, <span class="string">&#x27;Outside Circle&#x27;</span>); <span class="comment">% 创建图例</span></span><br><span class="line"><span class="built_in">hold</span> off; <span class="comment">% 停止保持绘图窗口</span></span><br><span class="line">s = (n/p)*<span class="number">4</span>;</span><br><span class="line">pi0 = s;</span><br><span class="line"><span class="built_in">disp</span>(pi0); <span class="comment">% 显示变量pi0的值</span></span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划算法的核心思想是：<strong>将大问题划分为小问题进行解决</strong>，从而一步步获取最优解的处理算法；动态规划算法和分治算法类似，基本思想也是将带求解问题分解成若干个子问题，先求子问题，然后从这些子问题的解得到原问题的解，与分治算法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，即下一个子阶段的求解是<strong>建立在上一个子阶段的解的基础上</strong>，进行进一步求解；动态规划可以通过<strong>填表</strong>的方式来逐步推进，得到最优解。</p>
<p>动态规划的解题核心就是找到状态转移方程，也就是数学上的递推公式</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230823005425878.png" alt="image-20230823005425878"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dynamic_programming</span>(<span class="params">problem</span>):</span><br><span class="line">    <span class="comment"># 创建一个存储子问题最优解的数组</span></span><br><span class="line">    dp = [<span class="literal">None</span>] * (problem_size + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 初始化边界条件</span></span><br><span class="line">    dp[<span class="number">0</span>] = initial_value</span><br><span class="line">    <span class="comment"># 逐步求解子问题</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, problem_size + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 解决子问题并存储最优解</span></span><br><span class="line">        dp[i] = solve_subproblem(i, dp)</span><br><span class="line">    <span class="comment"># 返回问题的最优解</span></span><br><span class="line">    <span class="keyword">return</span> dp[problem_size]</span><br></pre></td></tr></table></figure>

<h3 id="贪心策略"><a href="#贪心策略" class="headerlink" title="*贪心策略"></a>*贪心策略</h3><p>贪心算法适用于一类特定的问题，即满足贪心选择性质和最优子结构性质的问题。贪心选择性质指的是在每一步选择中都采取当前最优的选择，而最优子结构性质指的是问题的最优解可以通过子问题的最优解来构建。以下是一些适合使用贪心算法的问题示例：</p>
<ol>
<li><p>集合覆盖问题：给定一个全集和一组集合，要求选取最少的集合来覆盖全集中的所有元素。</p>
</li>
<li><p>最短路径问题（一定条件下）：在图中找到从一个起点到终点的最短路径。当图中不存在负权边时，贪心算法可以用于解决一些特定情况下的最短路径问题，如Dijkstra算法。</p>
</li>
<li><p>活动选择问题：给定一组活动，每个活动有一个开始时间和结束时间，要求选择最多的互不冲突的活动。</p>
</li>
<li><p>零钱找零问题：给定一定面额的硬币，要求用最少的硬币找零。</p>
</li>
<li><p>背包问题（一定条件下）：给定一组物品和一个背包容量，每个物品有一个价值和重量，要求选择最有价值的物品放入背包中。在某些限制条件下，如每个物品只能选择一次且物品可以分割，贪心算法可以用于解决部分背包问题或分数背包问题。</p>
</li>
<li><p>集合覆盖问题：给定一个全集和一组集合，要求选取最少的集合来覆盖全集中的所有元素。</p>
</li>
<li><p>最短路径问题（一定条件下）：在图中找到从一个起点到终点的最短路径。当图中不存在负权边时，贪心算法可以用于解决一些特定情况下的最短路径问题，如Dijkstra算法。</p>
</li>
<li><p>活动选择问题：给定一组活动，每个活动有一个开始时间和结束时间，要求选择最多的互不冲突的活动。</p>
</li>
<li><p>零钱找零问题：给定一定面额的硬币，要求用最少的硬币找零。</p>
</li>
<li><p>背包问题（一定条件下）：给定一组物品和一个背包容量，每个物品有一个价值和重量，要求选择最有价值的物品放入背包中。在某些限制条件下，如每个物品只能选择一次且物品可以分割，贪心算法可以用于解决部分背包问题或分数背包问题。</p>
</li>
</ol>
<p>matlab实现贪心策略：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selected_sets</span> = <span class="title">greedy_set_cover</span><span class="params">(universe, sets)</span></span></span><br><span class="line">    selected_sets = &#123;&#125;;  <span class="comment">% 存储选择的集合</span></span><br><span class="line">    covered_elements = [];  <span class="comment">% 存储已覆盖的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ~<span class="built_in">isempty</span>(universe)  <span class="comment">% 未覆盖的元素不为空</span></span><br><span class="line">        <span class="comment">% 计算每个集合与未覆盖元素的交集大小</span></span><br><span class="line">        intersection_sizes = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(sets));</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(sets)</span><br><span class="line">            intersection_sizes(<span class="built_in">i</span>) = <span class="built_in">length</span>(<span class="built_in">intersect</span>(sets&#123;<span class="built_in">i</span>&#125;, universe));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 找到交集大小最大的集合</span></span><br><span class="line">        [~, max_index] = <span class="built_in">max</span>(intersection_sizes);</span><br><span class="line">        selected_set = sets&#123;max_index&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 更新已覆盖元素和未覆盖元素</span></span><br><span class="line">        covered_elements = union(covered_elements, selected_set);</span><br><span class="line">        universe = setdiff(universe, selected_set);</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 将选择的集合添加到结果中</span></span><br><span class="line">        selected_sets = [selected_sets, selected_set];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 示例问题</span></span><br><span class="line">universe = <span class="number">1</span>:<span class="number">10</span>;  <span class="comment">% 全集</span></span><br><span class="line">sets = &#123;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>]&#125;;  <span class="comment">% 集合列表</span></span><br><span class="line"></span><br><span class="line">selected_sets = greedy_set_cover(universe, sets);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;选择的集合:&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(selected_sets)</span><br><span class="line">    <span class="built_in">disp</span>(selected_sets&#123;<span class="built_in">i</span>&#125;);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>python实现贪心策略;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greedy_set_cover</span>(<span class="params">universe, sets</span>):</span><br><span class="line">    selected_sets = []  <span class="comment"># 存储选择的集合</span></span><br><span class="line">    covered_elements = <span class="built_in">set</span>()  <span class="comment"># 存储已覆盖的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> universe:  <span class="comment"># 未覆盖的元素不为空</span></span><br><span class="line">        <span class="comment"># 计算每个集合与未覆盖元素的交集大小</span></span><br><span class="line">        intersection_sizes = [<span class="built_in">len</span>(<span class="built_in">set</span>.intersection(<span class="built_in">set</span>(s), universe)) <span class="keyword">for</span> s <span class="keyword">in</span> sets]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到交集大小最大的集合</span></span><br><span class="line">        max_index = <span class="built_in">max</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(sets)), key=<span class="keyword">lambda</span> i: intersection_sizes[i])</span><br><span class="line">        selected_set = sets[max_index]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新已覆盖元素和未覆盖元素</span></span><br><span class="line">        covered_elements.update(selected_set)</span><br><span class="line">        universe.difference_update(selected_set)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将选择的集合添加到结果中</span></span><br><span class="line">        selected_sets.append(selected_set)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> selected_sets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例问题</span></span><br><span class="line">universe = <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))  <span class="comment"># 全集</span></span><br><span class="line">sets = [&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;]  <span class="comment"># 集合列表</span></span><br><span class="line"></span><br><span class="line">selected_sets = greedy_set_cover(universe, sets)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;选择的集合:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> selected_sets:</span><br><span class="line">    <span class="built_in">print</span>(s) </span><br></pre></td></tr></table></figure>

<h1 id="图论模型"><a href="#图论模型" class="headerlink" title="图论模型"></a>图论模型</h1><h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><p>图：指的是一个二元组(V(G), E(G))<br>       V(G) &#x3D; {v1, v2, v3, … ,vn } 是非空有限集，称为<strong>顶点集</strong>，其中元素称为图G的<strong>顶点</strong><br>       E(G) 是顶点集V(G)中的无序或有序的元素偶对(vi, vj)组成的集合，称之为<strong>边集</strong>，其中元素称之为<strong>边</strong></p>
<p>图G的<strong>阶</strong>是指图的顶点数 | V(G) | 用v来表示；图的边的数目| E(G) | 用ε 来表示</p>
<p>用 G  &#x3D; ( V(G), E(G) )表示图，简记为G &#x3D; (V, E);也用vi，vj来表示边(vi, vj)</p>
<p>若一个图的顶点集和边集都是有限集，则称其为<strong>有限图</strong>，只有一个顶点的图称之为<strong>平凡图</strong>，其他的图都称为<strong>非平凡图</strong></p>
<p>若图G中的边均为<strong>有序</strong>偶对(vi, vj)，则称G为<strong>有向图</strong>。称边e &#x3D; (vi, vj)为<strong>有向边</strong>或<strong>弧</strong>，称e &#x3D; (vi, vj)是从vi<strong>连接</strong>vj，称vi为e的尾，称vj为e的头。</p>
<p>若图G中的边均为无序偶对vivj，称G为无向图。称边e &#x3D; (vi, vj)为无向边，称e<strong>连接</strong>vi和vj，顶点vi和vj称为e的<strong>端点</strong>。既有无向边又有有向边的图称之为混合图。</p>
<h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230825235208763.png" alt="image-20230825235208763"></p>
<ol>
<li>边和它的两端点称为互相<strong>关联</strong></li>
<li>与同一条边关联的两个端点称为<strong>相邻</strong>的顶点（如图中v2和v3），与同一个顶点相关联的两条边称为<strong>相邻</strong>的边（如图中e2和e3）</li>
<li>端点重合为一点的边称之为<strong>环</strong>（如图中e1和e5），端点不相同的边称为<strong>连杆</strong>(如图中e3和e4)</li>
<li>若一对顶点之间有两条以上的边联结，则这些边称之为<strong>重边</strong>（如图中e5和e6）</li>
<li>既没有环也没有重边的图称为简单图</li>
<li>任意两顶点都相邻的简单图称之为完全图。记为Kv，如下图</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826000031872.png" alt="image-20230826000031872"></p>
<ol start="7">
<li>若V(G) &#x3D; X ∪Y, X∩Y&#x3D; ø,且X中任意两顶点不相邻，Y中任意两顶点不相邻，则称为<strong>二部图</strong>或<strong>偶图</strong>；若X中每一顶点皆与Y中一切顶点相邻，称为<strong>完全二部图</strong>或<strong>完全偶图</strong>，记为Km,n(m&#x3D;|X|, n&#x3D;|Y|)</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826000814543.png" alt="image-20230826000814543"></p>
<ol start="8">
<li>图K1,n叫做星</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826000910601.png" alt="image-20230826000910601"></p>
<h3 id="赋权图和子图"><a href="#赋权图和子图" class="headerlink" title="赋权图和子图"></a>赋权图和子图</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>若G  &#x3D; ( V(G), E(G) )的每一条边e都赋以一个实数w(e)，称w(e)为边e的<strong>权</strong>，G连同边上的权称为<strong>赋权图</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826201423734.png" alt="image-20230826201423734"></p>
<h3 id="图的矩阵表示"><a href="#图的矩阵表示" class="headerlink" title="图的矩阵表示"></a>图的矩阵表示</h3><p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826201627590.png" alt="image-20230826201627590"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826202852564.png" alt="image-20230826202852564"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826203853696.png" alt="image-20230826203853696"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826204232673.png" alt="image-20230826204232673"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230826204350030.png" alt="image-20230826204350030"></p>
<h3 id="图的顶点度"><a href="#图的顶点度" class="headerlink" title="图的顶点度"></a>图的顶点度</h3><p>在<strong>无向图</strong>G中，与顶点v关联的边的数目（环算两次），称为顶点v的<strong>度</strong>或<strong>次数</strong>，记为d(v)或d<em>G</em>(V)称度为奇数的顶点为<strong>奇点</strong>，度为偶数的顶点为<strong>偶点</strong></p>
<p>在有向图中，从顶点v引出的边的数目称为顶点v的<strong>出度</strong>，记为d+(v)，从顶点v引入的边的数目称为v的入度，记为d-(v)。称d(v) &#x3D;  d+(v) + d-(v)为顶点的<strong>度</strong>或者<strong>次数</strong></p>
<h3 id="路和连通"><a href="#路和连通" class="headerlink" title="路和连通"></a>路和连通</h3><ol>
<li>无向图G的一条<strong>途径（或通道或链）</strong>是指一个有限非空序列W &#x3D; v0e1v1e2…ekvk，它的项交替地称为顶点和边，使得对1 ≤ i ≤ k，ei的端点是vi-1和vi，称W是v0到vk的一条途径，或一条(v0, vk)途径。整数k称为W的长。顶点v0和vk分别称为<strong>起点和终点</strong>，而v1,v2,…,vk-1称为W的内部顶点</li>
<li>若途径W的边互不相同但顶点可以重复，则称W为<strong>迹</strong>或<strong>简单链</strong></li>
<li>若途径W的顶点和边均互不相同，则称W为<strong>路</strong>或<strong>路径</strong>。一条起点为v0，终点为Vk的路径称为(v0, vk)路，记为P(v0, vk)</li>
<li>途径W &#x3D; v0e1v1e2…ekvk中由相继项构成子序列vi ei+1 vi+1…ejvj 称为途径W的节</li>
<li>起点和终点相重合的途径称为<strong>闭途径</strong>。起点和终点重合的路称为<strong>圈</strong>（或<strong>回路</strong>），长为k的圈称为<strong>k阶圈</strong>，记为Ck</li>
<li>若在图G中存在(u, v)路，则称顶点u和v在图G中连通</li>
<li>若在图G中顶点u和v是连通的，则顶点u和v之间的距离d(u, v)是指图G中最短(u, v)路的长；若没有路连接u和v，则定义为无穷大</li>
<li>图G中任意两点皆连通的图称为<strong>连通图</strong></li>
<li>对于有向图G，若W &#x3D; v0e1v1e2…ekvk，且ei有头vi和尾vi-1，则称W为<strong>有向途径</strong>，类似的可以定义<strong>有向迹</strong>，<strong>有向路</strong>和<strong>有向圈</strong></li>
</ol>
<h2 id="最短路问题及算法"><a href="#最短路问题及算法" class="headerlink" title="最短路问题及算法"></a>最短路问题及算法</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>用于求赋权图中从给定点到其余顶点的最短路</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>初始化：<br>将起始节点的距离设置为0，将所有其他节点的距离设置为无穷大。<br>将起始节点标记为当前节点。</p>
</li>
<li><p>迭代过程：<br>a. 对于当前节点，计算从起始节点到当前节点的距离加上从当前节点出发到相邻节点的距离。<br>   如果这个距离小于相邻节点的当前距离，则更新相邻节点的距离为这个更小的值。<br>b. 从尚未访问的节点中选择距离最小的节点作为下一个当前节点，并标记它为已访问。</p>
</li>
</ol>
<p>重复直到所有节点都被标记为已访问</p>
<ol start="3">
<li>最终结果：<br>当所有节点都被标记为已访问时，算法结束。<br>每个节点的最短路径距离就是其当前距离。</li>
</ol>
<h4 id="matlab实现Dijkstra算法"><a href="#matlab实现Dijkstra算法" class="headerlink" title="matlab实现Dijkstra算法"></a>matlab实现Dijkstra算法</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[shortestPath, shortestDistance]</span> = <span class="title">dijkstra</span><span class="params">(graph, start, target)</span></span></span><br><span class="line">    numNodes = <span class="built_in">size</span>(graph, <span class="number">1</span>);</span><br><span class="line">    distances = Inf(<span class="number">1</span>, numNodes);  <span class="comment">% 初始化距离向量</span></span><br><span class="line">    distances(start) = <span class="number">0</span>;</span><br><span class="line">    prevNodes = <span class="built_in">zeros</span>(<span class="number">1</span>, numNodes);  <span class="comment">% 初始化前驱节点向量</span></span><br><span class="line">    visited = <span class="built_in">false</span>(<span class="number">1</span>, numNodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> any(~visited)</span><br><span class="line">        [~, current] = <span class="built_in">min</span>(distances(~visited));</span><br><span class="line">        current = <span class="built_in">find</span>(~visited, <span class="number">1</span>) + current - <span class="number">1</span>;</span><br><span class="line">        visited(current) = <span class="built_in">true</span>;</span><br><span class="line"></span><br><span class="line">        neighbors = <span class="built_in">find</span>(graph(current, :));</span><br><span class="line">        <span class="keyword">for</span> neighbor = neighbors</span><br><span class="line">            distance = distances(current) + graph(current, neighbor);</span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances(neighbor)</span><br><span class="line">                distances(neighbor) = distance;</span><br><span class="line">                prevNodes(neighbor) = current;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 构建最短路径</span></span><br><span class="line">    path = [];</span><br><span class="line">    node = target;</span><br><span class="line">    <span class="keyword">while</span> node ~= <span class="number">0</span></span><br><span class="line">        path = [node, path];</span><br><span class="line">        node = prevNodes(node);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    shortestPath = path;</span><br><span class="line">    shortestDistance = distances(target);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 示例图数据结构</span></span><br><span class="line">graph = [</span><br><span class="line">    <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">startNode = <span class="number">1</span>;</span><br><span class="line">targetNode = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">[shortestPath, shortestDistance] = dijkstra(graph, startNode, targetNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最短路径:&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(shortestPath);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最短距离:&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(shortestDistance);</span><br></pre></td></tr></table></figure>

<h4 id="Python实现Dijkstra算法"><a href="#Python实现Dijkstra算法" class="headerlink" title="Python实现Dijkstra算法"></a>Python实现Dijkstra算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start, target</span>):</span><br><span class="line">    distances = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;  <span class="comment"># 初始化距离字典</span></span><br><span class="line">    distances[start] = <span class="number">0</span>  <span class="comment"># 起始节点距离设置为0</span></span><br><span class="line">    prev_nodes = &#123;node: <span class="literal">None</span> <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;  <span class="comment"># 初始化前驱节点字典</span></span><br><span class="line">    visited = <span class="built_in">set</span>()  <span class="comment"># 已访问节点集合</span></span><br><span class="line"></span><br><span class="line">    priority_queue = [(<span class="number">0</span>, start)]  <span class="comment"># 优先队列，用于选择距离最小的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> priority_queue:</span><br><span class="line">        current_distance, current_node = heapq.heappop(priority_queue)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_node == target:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_node <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        visited.add(current_node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[current_node].items():</span><br><span class="line">            distance = current_distance + weight</span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[neighbor]:</span><br><span class="line">                distances[neighbor] = distance</span><br><span class="line">                prev_nodes[neighbor] = current_node</span><br><span class="line">                heapq.heappush(priority_queue, (distance, neighbor))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建最短路径</span></span><br><span class="line">    path = []</span><br><span class="line">    node = target</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        path.insert(<span class="number">0</span>, node)</span><br><span class="line">        node = prev_nodes[node]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path, distances[target]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例图数据结构</span></span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>: &#123;<span class="string">&#x27;D&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_node = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">target_node = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"></span><br><span class="line">shortest_path, shortest_distance = dijkstra(graph, start_node, target_node)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短路径:&quot;</span>, shortest_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短距离:&quot;</span>, shortest_distance)</span><br></pre></td></tr></table></figure>

<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>用于求赋权图中任意两顶点间的最短路</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230828012347590.png" alt="image-20230828012347590"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230828012502430.png" alt="image-20230828012502430"></p>
<p>Python实现Floyd算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">floyd</span>(<span class="params">graph</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    dist = graph  <span class="comment"># 初始距离矩阵，即邻接矩阵</span></span><br><span class="line">    next_hop = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 记录最短路径上的下一跳节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j]</span><br><span class="line">                    next_hop[i][j] = k</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist, next_hop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例邻接矩阵</span></span><br><span class="line">graph = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">5</span>, sys.maxsize, <span class="number">10</span>],</span><br><span class="line">    [sys.maxsize, <span class="number">0</span>, <span class="number">3</span>, sys.maxsize],</span><br><span class="line">    [sys.maxsize, sys.maxsize, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [sys.maxsize, sys.maxsize, sys.maxsize, <span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">distances, next_hops = floyd(graph)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最短路径距离</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短路径距离矩阵:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> distances:</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> row:</span><br><span class="line">        <span class="keyword">if</span> val == sys.maxsize:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inf&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最短路径上的下一跳节点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下一跳节点矩阵:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> next_hops:</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<p>matlab实现Floyd算法：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[dist, next_hop]</span> = <span class="title">floyd</span><span class="params">(graph)</span></span></span><br><span class="line">    n = <span class="built_in">size</span>(graph, <span class="number">1</span>);</span><br><span class="line">    dist = graph;  <span class="comment">% 初始距离矩阵，即邻接矩阵</span></span><br><span class="line">    next_hop = -<span class="built_in">ones</span>(n, n);  <span class="comment">% 记录最短路径上的下一跳节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">if</span> dist(<span class="built_in">i</span>, <span class="built_in">j</span>) &gt; dist(<span class="built_in">i</span>, k) + dist(k, <span class="built_in">j</span>)</span><br><span class="line">                    dist(<span class="built_in">i</span>, <span class="built_in">j</span>) = dist(<span class="built_in">i</span>, k) + dist(k, <span class="built_in">j</span>);</span><br><span class="line">                    next_hop(<span class="built_in">i</span>, <span class="built_in">j</span>) = k;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 示例邻接矩阵</span></span><br><span class="line">graph = [</span><br><span class="line">    <span class="number">0</span>, <span class="number">5</span>, <span class="built_in">inf</span>, <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">inf</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="built_in">inf</span>;</span><br><span class="line">    <span class="built_in">inf</span>, <span class="built_in">inf</span>, <span class="number">0</span>, <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">inf</span>, <span class="built_in">inf</span>, <span class="built_in">inf</span>, <span class="number">0</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">[distances, next_hops] = floyd(graph);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 打印最短路径距离</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最短路径距离矩阵:&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(distances);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 打印最短路径上的下一跳节点</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;下一跳节点矩阵:&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(next_hops);</span><br></pre></td></tr></table></figure>

<h1 id="多目标规化模型"><a href="#多目标规化模型" class="headerlink" title="多目标规化模型"></a>多目标规化模型</h1><h2 id="解的情况"><a href="#解的情况" class="headerlink" title="解的情况"></a>解的情况</h2><h3 id="解A优于解B"><a href="#解A优于解B" class="headerlink" title="解A优于解B"></a>解A优于解B</h3><p>对于两个目标函数，解A对应的目标函数值都比解B对应对目标函数值好，那么称解A比解B优越，也可称解A强帕累托支配解B</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903213419486.png" alt="image-20230903213419486"></p>
<h3 id="解A无差别于解B"><a href="#解A无差别于解B" class="headerlink" title="解A无差别于解B"></a>解A无差别于解B</h3><p>对于两个目标函数，解A对应的一个目标函数值优于解B对应的一个目标函数值，但是解A对应的另一个目标函数值要差于解B对应的一个目标函数值，则称解A无差别于解B，也叫解A能帕累托支配解B</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903213707600.png" alt="image-20230903213707600"></p>
<h3 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h3><p>在空间当中，解A对应的目标函数值优越其他任何解，则称解A为最优解。但由于多个函数值同时达到最优的情况在现实中是不可能存在的，由此提出来帕累托最优解</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903213852282.png" alt="image-20230903213852282"></p>
<h2 id="帕累托最优"><a href="#帕累托最优" class="headerlink" title="帕累托最优"></a>帕累托最优</h2><p>多目标优化需要同时解决多个目标，通常这些目标都是相互影响的，所以一般这些目标无法同时达到最优情况，而多目标优化的目的就是尽可能找到一定范围内的最佳状态，这个思想称为帕累托理论</p>
<h3 id="帕累托最优解"><a href="#帕累托最优解" class="headerlink" title="帕累托最优解"></a>帕累托最优解</h3><p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903214155404.png" alt="image-20230903214155404"></p>
<p>如上图所示，x1为f1的最优值，所以x1一个帕累托最优解，同理x2也是一个帕累托最优解。实际上，对于[ x1, x2 ]中的每一个点都是帕累托最优解</p>
<h3 id="帕累托最优前沿"><a href="#帕累托最优前沿" class="headerlink" title="帕累托最优前沿"></a>帕累托最优前沿</h3><p>帕累托最优解对应的目标函数值就是帕累托最优前沿。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903214510393.png" alt="image-20230903214510393"></p>
<p>如上图所示，在可行区域中的A到F点都是帕累托最优解，其所在曲线AF上的点也是帕累托最优解。</p>
<h2 id="传统解法"><a href="#传统解法" class="headerlink" title="传统解法"></a>传统解法</h2><h3 id="线性加权法"><a href="#线性加权法" class="headerlink" title="线性加权法"></a>线性加权法</h3><p>在实际生产中，对于目标往往有不同的倾向和偏好，转换为数学语言就是每个目标函数都有不同的权重值，基于这个思想，可以对多目标规划当中的每一个目标函数附上人为给定点权重，进而把多目标规划转化为单目标规划，具体表达如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903214905998.png" alt="image-20230903214905998"></p>
<p>该方法适用于有专家打分等实际生产环境当中，能得到较为符合实际的满意解。而在不知道权重更多新问题下，可以尝试搜索算法来寻找最佳权重。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_weighting_method</span>(<span class="params">objectives, weights</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    线性加权法进行多目标规划</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    objectives (list of arrays): 目标函数列表，每个目标函数为一个一维数组</span></span><br><span class="line"><span class="string">    weights (list): 目标函数的权重列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">    best_solution (array): 最优解</span></span><br><span class="line"><span class="string">    best_score (float): 最优解的得分</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_objectives = <span class="built_in">len</span>(objectives)</span><br><span class="line">    num_variables = objectives[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归一化权重</span></span><br><span class="line">    weights = np.array(weights)</span><br><span class="line">    weights /= np.<span class="built_in">sum</span>(weights)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化最优解和得分</span></span><br><span class="line">    best_solution = <span class="literal">None</span></span><br><span class="line">    best_score = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有解空间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_variables):</span><br><span class="line">        solution = np.zeros(num_variables)</span><br><span class="line">        solution[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算得分</span></span><br><span class="line">        score = np.dot(weights, [obj[solution] <span class="keyword">for</span> obj <span class="keyword">in</span> objectives])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新最优解和得分</span></span><br><span class="line">        <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">            best_solution = solution</span><br><span class="line">            best_score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_solution, best_score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例问题</span></span><br><span class="line"><span class="comment"># 目标函数列表</span></span><br><span class="line">objectives = [</span><br><span class="line">    np.array([<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]),</span><br><span class="line">    np.array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>]),</span><br><span class="line">    np.array([<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标函数的权重列表</span></span><br><span class="line">weights = [<span class="number">0.4</span>, <span class="number">0.3</span>, <span class="number">0.3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用线性加权法求解多目标规划</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> distance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ideal_point_method</span>(<span class="params">objective_functions, population</span>):</span><br><span class="line">    <span class="comment"># 计算参考点（Ideal Point）</span></span><br><span class="line">    ideal_point = np.<span class="built_in">min</span>(population, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算个体与参考点之间的距离</span></span><br><span class="line">    distances = distance.cdist(population, [ideal_point], <span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据距离进行排序</span></span><br><span class="line">    sorted_indices = np.argsort(distances, axis=<span class="number">0</span>).flatten()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回排序后的个体</span></span><br><span class="line">    sorted_population = population[sorted_indices]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每个个体的排名</span></span><br><span class="line">    ranks = np.argsort(sorted_indices, axis=<span class="number">0</span>).flatten()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回排名和距离</span></span><br><span class="line">    <span class="keyword">return</span> ranks, distances.flatten()</span><br></pre></td></tr></table></figure>

<h3 id="优先级法"><a href="#优先级法" class="headerlink" title="优先级法"></a>优先级法</h3><p>优先级法的主要思路就是根据目标重要性分成不同优先级，先求优先级高的目标函数最优值，在确保优先级高的目标获得不低于最优质的条件下，再求优先级低的目标函数</p>
<p>以一个双目标规划问题为例</p>
<p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903215623369.png" alt="image-20230903215623369"></p>
<p>以此类推，对于目标数大于两个的多目标规划模型均可根据上述思路求解</p>
<h3 id="理想点法"><a href="#理想点法" class="headerlink" title="理想点法"></a>理想点法</h3><p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903220455022.png" alt="image-20230903220455022"></p>
<h2 id="智能算法"><a href="#智能算法" class="headerlink" title="智能算法"></a>智能算法</h2><p>对于传统算法，由于构造的函数往往是非凸函数，尝尝找不到相对较好的解；同时受限于计算的特点，每次运行只能产生一个解，求解多个时要多次运行，而且无法得到均匀分布的帕累托最优解集。为了解决这个问题，可以通过迭代搜索的形式寻找多个帕累托最优解，并画出帕累托前沿曲线</p>
<h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p><img src="https://cdn.jsdelivr.net/gh/Pbbb1002/MyBlog@main/img/image-20230903221254735.png" alt="image-20230903221254735"></p>
<p>使用Python实现非支配排序遗传算法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> greatpy <span class="keyword">import</span> Problem, NSGA2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义多目标优化问题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProblem</span>(<span class="title class_ inherited__">Problem</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(num_of_variables=<span class="number">2</span>, num_of_objectives=<span class="number">2</span>, num_of_constraints=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">self, solution</span>):</span><br><span class="line">        x = solution.variables</span><br><span class="line">        f1 = x[<span class="number">0</span>]**<span class="number">2</span> + x[<span class="number">1</span>]**<span class="number">2</span></span><br><span class="line">        f2 = (x[<span class="number">0</span>]-<span class="number">1</span>)**<span class="number">2</span> + x[<span class="number">1</span>]**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> [f1, f2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建问题实例</span></span><br><span class="line">problem = MyProblem()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义算法参数</span></span><br><span class="line">population_size = <span class="number">50</span></span><br><span class="line">num_generations = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建NSGA-II算法实例</span></span><br><span class="line">algorithm = NSGA2(problem, population_size=population_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行NSGA-II算法</span></span><br><span class="line">results = algorithm.run(num_generations)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出最优解集合</span></span><br><span class="line"><span class="keyword">for</span> solution <span class="keyword">in</span> results.solutions:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Variables: <span class="subst">&#123;solution.variables&#125;</span>, Objectives: <span class="subst">&#123;solution.objectives&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h1><p>分类算法是机器学习中的一类算法，用于将数据集中的样本划分到不同的类别或标签中。分类算法通过学习从已标记的训练数据中提取特征和模式，并使用这些特征和模式来预测新样本的类别。</p>
<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><h1 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h1>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a>
              <a href="/tags/%E5%BB%BA%E6%A8%A1/" rel="tag"># 建模</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/08/22/Python%E4%BB%A3%E7%A0%81%E5%8C%85/" rel="prev" title="Python代码包">
                  <i class="fa fa-chevron-left"></i> Python代码包
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/30/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/" rel="next" title="数学建模——数据预处理">
                  数学建模——数据预处理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">彭 斌</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">48k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:55</span>
  </span>
</div>

    </div>
  </footer>

  

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>


  





</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

